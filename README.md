Proof Drive Development Example
===============================

このサンプルは「[整数の閉区間](https://gist.github.com/twada/75fb219c8cc180e9de166d8a58e877b0)」に基づくものです。



仕様番号の網羅性チェック
------------------------

| 仕様番号 | 実装状況 | 仕様 |
|:---------|:---------|:-----|
| NLS-1    | X        | 整数閉区間を示すクラス（あるいは構造体）をつくりたい。 |
| NLS-2    | X        | 整数閉区間オブジェクトは下端点と上端点を持ち、 |
| NLS-3    | X        | 文字列表現も返せる |
| NLS-4    | X        | （例: 下端点 3, 上端点 8 の整数閉区間の文字列表記は `"[3,8]"`）。 |
| NLS-5    | X        | ただし、上端点より下端点が大きい閉区間を作ることはできない。 |
| NLS-6    | X        | 整数の閉区間は指定した整数を含むかどうかを判定できる。 |
| NLS-7    | X        | また、別の閉区間と等価かどうかや、 |
| NLS-8    | X        | 完全に含まれるかどうかも判定できる。 |
| NLS-9    | X        | 例: 閉区間 `[3,8]` の場合`[3,8]` |
| NLS-10   | X        | → 下端点 (lower endpoint) が 3 , 上端点 (upper endpoint) が 8 である整数閉区間 |
| NLS-11   | X        | → 3 と 8 は区間に含まれる |
| NLS-12   | X        | → つまり (整数閉区間だから) 3,4,5,6,7,8 |



見つけた仕様の曖昧さ（ちょっと微妙だけれど）
-------------------------------------------

NLS-12 の解釈を何も考えずに書いてあるとおり「集合 `{ 3, 4, 5, 6, 7, 8 }` の要素を `n` とし、すべての要素について `in_range n (3, 8)` が真である」と解釈すると、実は雑な定義 `in_range _ = True` （どんな自然数でも真とする）で成立してしまう。

```isabelle
(* どんな自然数でも真とする FakeIt な関数 *)
fun in_range :: "int ⇒ (int × int) ⇒ bool" where
    "in_range _ = True"

(* 集合 { 3, 4, 5, 6, 7, 8 } の要素を n とし、すべての要素について in_range n (3, 8) が真になることを証明する *)
example_3_8_strong: "∀n ∈ { 3, 4, 5, 6, 7, 8 }. in_range2 n (3, 8)"
  apply(auto)

  (* このときの証明の状態:

      goal:
      No subgoals!

    FakeIt なのに証明が成功してしまった…
   *)
```

どうしてこんなことになるかというと、NLS-12 には 3, 4, 5, 6, 7, 8 で以外について明示的に仕様が書かれていないから。

一般に、明示的に仕様が書かれていない場合次の2つの場合がありうる：

1. 未定義: どんな結果になってもいい
2. 定義の書き漏れ: 実際には期待されている定義が存在するが、暗黙になってしまっている

今回のケースでは前者として解釈（つまり 3-8 以外ではどんな結果でもいい）としてしまうと、実装側はすべて真としてしまっても仕様を満たしていることになる。しかし、常識的にはすべてを真という関数が無益であるので変だと気づいて、後者の解釈（なんらかの結果が期待されている）で読まないといけない。

要するに、NLS-12 を読む際には心の中で「それ以外は False」と付け加えないといけない。このように NLS-12 を解釈して論理式に落とせれば雑な定義の証明は成功しない。

```isabelle
(* 自然数 n について、n が集合 { 3, 4, 5, 6, 7, 8 } の要素のときのみ in_range n (3, 8) が真になり、
   そうでなければ in_range n (3, 8) は偽になることを証明する *)
theorem "∀n. n ∈ { 3, 4, 5, 6, 7, 8 } ⟷ in_range2 n (3, 8)"
  apply(auto)

  (* このときの証明の状態:

       goal (1 subgoal):
        1. ⋀n. ⟦n ≠ 3; n ≠ 4; n ≠ 5; n ≠ 6; n ≠ 8⟧ ⟹ n = 7

     どんな自然数 n でも n が 3, 4, 5, 6, 8 のいずれでもないなら、n が 7 になることを証明しないといけない。
     もちろん、そんなことは証明できないのでこの辺りで FakeIt 直し忘れてたと気づく。
     ただし、もし in_range の定義域が自然数全体ではなく 3-8 だけだったならば、
     3-8 以外のケースはないと言えるので証明できるという意味でもある。
   *)
```
